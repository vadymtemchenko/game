{
  "name": "dateutil",
  "version": "0.1.0",
  "author": {
    "name": "Borgar Þorsteinsson",
    "email": "borgar@borgar.net",
    "url": "http://borgar.net/"
  },
  "description": "A date parsing and formatting library. Complete ISO 8061 date/time parsing support including quarters and years. Full PHP style date formatting.",
  "repository": {
    "type": "git",
    "url": "git://github.com/borgar/dateutil.git"
  },
  "main": "./dateutil.js",
  "engines": {
    "node": "*"
  },
  "tags": [
    "date",
    "time",
    "format",
    "PHP",
    "parse",
    "ISO 8601"
  ],
  "bugs": {
    "url": "https://github.com/borgar/dateutil/issues"
  },
  "readme": "# Dateutil\n\nDateutil is a modest collection of utility methods for manipulating dates. It works both in Node.JS and in browsers. It's goal is to provide extendable mechanisms for parsing and formatting dates, as well as other convenient date methods.\n\nCurrently, the library supports formatting of nearly full spec of PHP style dates (minus the really useless bits), and parses about the full range of ISO 8901 formats. It supports translations (for formatter) but no timezones.\n\n## Dateutil methods\n\n### dateutil.date( [year], [month], [day], [hour], [min], [sec], [ms] )\n\nFunction returns a new *Date* instance set to the expected date. If no arguments are given, then it returns the current date. When any arguments are given they are handled in much the same way the native date constructor does, except the first argument is always treated as a year.\n\nIt is safe to pass strings as arguments.\n\n**Please note:** Months are zero based in set just as they are in native *Date* construction.\n\n\n\n### dateutil.isLeapYear( date / year )\n\nFunction accepts a *Date*, or a year, and will return true if the year is a leap year or false if not.\n\n    dateutil.isLeapYear( 1468 ) == true\n\n\n### dateutil.daysInMonth( date )\n\nFunction accepts a *Date* and returns the number of days in it's month.\n\n    dateutil.daysInMonth( new Date(1920, 3, 1) ) == 30\n\n\n### dateutil.isocalendar( date )\n\nFunction accepts a *Date* and returns a three value array containing the ISO 8901 year, week, and day (of the week), respectively.\n\n    dateutil.isocalendar( new Date(2010, 0, 3) ) == [2009, 53, 7]\n\n\n### dateutil.set( date, values )\n\nFunction accepts a *Date* and an object of values. The function returns the input date (same instance) having set the units specified in the values collection.\n\n    var mydate = new Date( 2000, 9, 16, 10, 45, 12 );\n    dateutil.set( mydate, { hour: 0, minute: 0, second: 0 });\n\n    result:  mydate == new Date( 2000, 9, 16, 0, 0, 0 );\n\nThe function will accept all or any of these keys: \n`year`, `month`, `day`, `hour`, `minute`, `second`, `millisecond`. and their plural forms (`years`, `minutes`, etc. ); and these shorthand variations: `yr` (year), `mn` (month), `day` (day), `hr` (hour), `min` (minute), `sec` (second), `ms` (millisecond).\n\n**Please note:** Months are zero based in set just as they are in native *Date* construction.\n\nThis function tries to avoid rollover gotchas that can occur when using native members to set date values. A simplified example of this:\n\n    var d = new Date( 1999, 1, 20 );\n    d.setUTCDate( 30 );   // Tue Mar 02 1999 00:00:00 GMT+0000 (GMT)\n    d.setUTCMonth( 0 );   // Sat Jan 02 1999 00:00:00 GMT+0000 (GMT)\n\nThe `dateutil.set` function is takes steps to avoid the problem:\n\n    var d = new Date( 1999, 1, 20 );\n    dateutil.set(d, {\n      'date': 30,\n      'month': 0\n    });  // Sat Jan 30 1999 00:00:00 GMT+0000 (GMT)\n\n    var d = new Date( 1999, 1, 20 );\n    dateutil.set(d, {\n      'month': 0,\n      'date': 30\n    });  // Sat Jan 30 1999 00:00:00 GMT+0000 (GMT)\n\nIf you want to be sure you get the correct date then you need to use the `dateutil.date` \n\n\n### dateutil.parse( string )\n\nFunction accepts a string (representing a date) and will output a *Date* based on parsing the string.\n\n    dateutil.parse('2005-01-01') == new Date(2005, 0, 1)\n\nThe function will aways return a *Date* instance, valid or not. Internally it falls back to native parser if it fails to recognize the format.\n\nA mostly complete list of recognized formats:\n\n* yyyy-mm-dd hh:mm:ss.ffff+0000 &nbsp; &mdash; *(timezone is currently ignored)*\n* yyyy-mm-dd hh:mm:ss.ffffZ\n* yyyy-mm-dd hh:mm:ss.ffff\n* yyyy-mm-dd hh:mm\n* yyyy-mm-ddThh:mm:ss.ffff+0000 &nbsp; &mdash; *(timezone is currently ignored)*\n* yyyy-mm-ddThh:mm:ss.ffffZ\n* yyyy-mm-ddThh:mm:ss.ffff\n* yyyy-mm-ddThh:mm\n* yyyy-mm-dd\n* yyyy-mmdd\n* yyyymmdd\n* yyyy-ddd &nbsp; &mdash; *year with day-of-the-year*\n* yyyy-Www-d\n* yyyy-Wwwd\n* yyyy-Www\n* yyyyWww-d\n* yyyyWwwd\n* yyyyWww\n* yyyy-Qq &nbsp; &mdash; *year with quarter*\n* yyyyQq\n* yyyy-mm\n* yyyy/mm\n* yyyy\n\n... In addition to the formats JavaScript can natively parse.\n\n\n#### Adding a custom parser\n\nYou may add your own parser by assigning them into `dateutil._parsers`. A parser is simply an object with two members: \n\n* `test`: a regular expression used to test if this date can be parsed by the parser. Keep these simple and avoid capture groups, or suffer the slowdown cost.\n* `parse`: a function that handles turning the string into a `Date` instance.\n\nAn contrived example:\n\n    // year + excel week\n    dateutil._parsers['year_and_excel_week'] = {\n      test: /^\\d{4}_[0-5]\\d$/,\n      parse: function ( str ) {\n        var bits = str.split('_');\n        var year = parseInt( bits[0], 10 );\n        var dofy = parseInt( bits[1], 10 );\n        return new Date( year, 0, ((dofy - 1) * 7) + 1);\n      }\n    };\n\n    // usage:\n    dateutil.parse('2002_31') == new Date(2002, 6, 30)\n\n\n### dateutil.format( date, format_string, [language] )\n\nFunction accepts a *Date, a *PHP* style [format string][1], and an optional language identifyer, and will return a formatted date string. Refer to the [PHP docs][1] for the full spec of available format characters.\n\n    var mydate = new Date( 2000, 9, 16, 10, 45, 12 );\n    dateutil.format( mydate, 'jS F Y' ) == \"16th October 2000\"\n\nThe `B`, `Z`, and `I` characters have been purposely omitted, and the following new characters added:\n\n* `q` &mdash; quarter of the year\n\nThe third optional parameter will get passed through the formatting system until it reaches \n\n\nThe format method is smart about being assigned to the `Date.prototype` object and will work as expected:\n\n    Date.prototype.format = dateutil.format;\n    new Date( 1975, 9, 16 ).format( 'Y-m-d' ) == \"1975-10-16\"\n\n\n#### Adding a custom formatter\n\nYou may add your own formatter by assigning them into `dateutil._formats`. A parser is simply a function that takes a *Date* parameter, a language parameter, and returns a string. \n\nAn example that adds *Swatch internet time* formatter:\n    \n    // Swatch Internet time\n    dateutil._formats['B'] = function (d) {\n      var mo = 0; // This should really be: isDST * 60 + timeZoneOffsetInMinutes\n      return Math.round( ( d.getUTCHours() * 3600 + \n            ( ( d.getUTCMinutes() - mo + 60 ) * 60 ) +\n              d.getUTCSeconds() ) * 1000 / 86400 ) % 1000;\n    };\n\n    var mydate = new Date( 1961, 0, 3, 1, 51, 10, 1 );\n    dateutil.format( mydate, 'B' ) == '119'\n\nIf you call `dateutil._`, or recursively call formatting or other specific formatting functions for delegating work, it is important that you keep passing the second parameter so that a specified language is perserved.\n\nAn example that adds upper case 4 letter month name:\n\n    dateutil._formats['R'] = function (d,l) {\n      var mont = this['F']( d, l );  // fetch translated month in \"l\" language\n      return mont.substr( 0, 4 ).toUpperCase();\n    };\n\n\n### dateutil.today()\n\nFunction returns a new *Date* instance set to the current day.\n\n\n### dateutil.now()\n\nFunction returns a new *Date* instance set to the current moment. Uses native implementation if it exists.\n\n\n### dateutil._( string, [language] )\n\nA string translation function. This function looks for the string argument as a key in `dateutil.lang[ language ]` and uses the the value if it exists, otherwise it falls back on the string argument.\n\nYou can feed the system translation strings and use it, or alternatively, if you already have another translation system then you can overwrite this function with your own translation function.\n\nIn order to use the built in system you would add translated strings like in this example (Icelandic language):\n\n    dateutil.lang.is = {\n      'January': 'janúar',\n      'February': 'febrúar',\n      'March': 'mars',\n      'April': 'apríl',\n      'May': 'maí',\n      'June': 'júní',\n      // and so on ...\n    };\n\nYou should provide translations for the following strings:\n\n* January February March April May June July August September October November December\n* Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n* Sunday Monday Tuesday Wednesday Thursday Friday Saturday\n* Sun Mon Tue Wed Thu Fri Sat\n\n\n\n\n\n[1]: http://php.net/manual/en/function.date.php\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/borgar/dateutil",
  "_id": "dateutil@0.1.0",
  "_from": "dateutil@"
}
